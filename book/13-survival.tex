
\chapter{생존분석}

{\bf 생존분석(Survival analysis)}은 무언가 얼마나 지속하는지를 기술하는 방법이다. 종종 사람 생명 연구에 사용되지만, 또한 기계나 전자 부품의 ``생존(survial)'' 혹은 좀더 일반적으로 사건 전 시간 간격에도 적용된다.
\index{생존분석 (survival analysis)}
\index{기계 부품 (mechanical component)}
\index{전자 부품 (electrical component)}

만약 여러분이 알고 있는 누군가 생명을 위협하는 질병을 진단받았다면, ``5년 생존율 (5-year survival rate)''을 들어봤을지도 모른다. 진단 후에 5년을 생존할 확률이다. 이 추정값과 관련된 통계량이 생존분석 결과다.
\index{생존율 (survival rate)}

이번 장에서 사용되는 코드는 {\tt survival.py}에 있다.
코드를 다운로드하고 작업하는 것에 대한 정보는 ~\ref{code}을 참조한다.


\section{생존곡선 (Survival curves)}
\label{survival}

생존분석에 기본 개념은 {\bf 생존곡선 (survival curve)} $S(t)$로,
존속 $t$를 $t$보다 더 오래 생존할 확률로 매핑하는 함수다.
만약 존속(duration) 분포 즉, ``수명(lifetimes)''을 알고 있다면,
생존곡선을 찾는 것은 쉽다; CDF의 여분포(complement)가 된다.
\index{생존곡선 (survival curve)}
%
\[ S(t) = 1 - \CDF(t) \]
%
여기서, $CDF(t)$는 $t$보다 적거나 같은 수명 확률이다.
\index{상보 CDF (complementary CDF)} 
\index{CDF!상보(complementary)} 
\index{CCDF}

예를 드어, NSFG 데이터셋에서 11189 출산 존속기간을 알고 있다.
이 데이터를 읽어서 CDF를 계산할 수 있다.
\index{임신기간 (pregnancy length)}

\begin{verbatim}
    preg = nsfg.ReadFemPreg()
    complete = preg.query('outcome in [1, 3, 4]').prglngth
    cdf = thinkstats2.Cdf(complete, label='cdf')
\end{verbatim}

결과 코드(outcome code) {\tt 1, 3, 4}은 정상출산, 사산, 유산을 각각 나타낸다.
분석을 위해서 유발유산(induced abortion), 자궁외 임신(ectopic pregnancy), 그리고 응답자와 인터뷰중에 임신상태인 경우는 제외한다.

데이터프레임 메쏘드 {\tt query}는 부울 표현식을 인자로 받아서 각 행마다 평가하고 참(True)을 산출하는 행을 선택한다.
\index{데이터프레임 (DataFrame)}
\index{부울 (boolean)}
\index{쿼리 (query)}

\begin{figure}
% survival.py
\centerline{\includegraphics[height=3.0in]{figs/survival1.pdf}}
\caption{Cdf and survival function for pregnancy length (top),
hazard function (bottom).}
\label{survival1}
\end{figure}

그림~\ref{survival1} (상단)에 임신기간 CDF와 생존함수인 상보 CDF가 보여진다. 생존함수를 표현하기 위해서, 객체를 정의해서 Cdf를 래핑(wrapping) 인터페이스를 조정하여 맞춘다(adapt).
\index{Cdf}
\index{임신기간 (pregnancy length)}
\index{SurvivalFunction}

\begin{verbatim}
class SurvivalFunction(object):
    def __init__(self, cdf, label=''):
        self.cdf = cdf
        self.label = label or cdf.label

    @property
    def ts(self):
        return self.cdf.xs

    @property
    def ss(self):
        return 1 - self.cdf.ps
\end{verbatim}

{\tt SurvivalFunction}는 프로퍼티(property)를 두개 제공한다; {\tt ts}는 수명 시퀀스고, {\tt ss}는 생존함수다.
파이썬에서 ``프로퍼티(property)''는 마치 변수처럼 호출할 수 있는 메쏘드다.

수명 CDF를 인자로 넘김으로써 {\tt SurvivalFunction}를 인스터스화할 수 있다.
\index{프로퍼티 (property)}

\begin{verbatim}
    sf = SurvivalFunction(cdf)
\end{verbatim}

또한 {\tt SurvivalFunction}는 \verb"__getitem__"와 {\tt Prob}을 제공하는데 생존함수를 평가한다.

\begin{verbatim}
# class SurvivalFunction

    def __getitem__(self, t):
        return self.Prob(t)

    def Prob(self, t):
        return 1 - self.cdf.Prob(t)
\end{verbatim}

예를 들어, {\tt sf[13]} 는 임신초기 3개월을 지난 임신 비율이다.
\index{임신 3개월 (trimester)}

\begin{verbatim}
>>> sf[13]
0.86022
>>> cdf[13]
0.13978
\end{verbatim}

약 86\% 임신이 첫 3개월을 지났다; 약 14\% 그렇지 못하다.

{\tt SurvivalFunction}는 {\tt Render} 기능있다. 그래서,
{\tt thinkplot}에 함수를 사용해서 {\tt sf} 플롯을 그릴 수 있다.
\index{thinkplot}

\begin{verbatim}
    thinkplot.Plot(sf)
\end{verbatim}

그림~\ref{survival1} (상단)에 결과가 나와 있다.

곡선은 거의 13주차에서 26주차는 거의 평평해서, 임신 중기에는 임신 몇몇사례만 중단되는 것을 보여준다. 그리고, 곡선이 39주차에 가장 가파른데 가장 흔한 임신기간이다.
\index{임신기간 (pregnancy length)}


\section{Hazard function}
\label{hazard}

From the survival function we can derive the {\bf hazard function};
for pregnancy lengths, the hazard function maps from a time, $t$, to
the fraction of pregnancies that continue until $t$ and then end at
$t$.  To be more precise:
%
\[ \lambda(t) = \frac{S(t) - S(t+1)}{S(t)} \]
%
The numerator is the fraction of lifetimes that end at $t$, which
is also $\PMF(t)$.
\index{hazard function}

{\tt SurvivalFunction} provides {\tt MakeHazard}, which calculates
the hazard function:

\begin{verbatim}
# class SurvivalFunction

    def MakeHazard(self, label=''):
        ss = self.ss
        lams = {}
        for i, t in enumerate(self.ts[:-1]):
            hazard = (ss[i] - ss[i+1]) / ss[i]
            lams[t] = hazard

        return HazardFunction(lams, label=label)
\end{verbatim}

The {\tt HazardFunction} object is a wrapper for a pandas
Series:
\index{pandas}
\index{Series}
\index{wrapper}

\begin{verbatim}
class HazardFunction(object):

    def __init__(self, d, label=''):
        self.series = pandas.Series(d)
        self.label = label
\end{verbatim}

{\tt d} can be a dictionary or any other type that can initialize
a Series, including another Series.  {\tt label} is a string used
to identify the HazardFunction when plotted.
\index{HazardFunction}

{\tt HazardFunction} provides \verb"__getitem__", so we can evaluate
it like this:

\begin{verbatim}
>>> hf = sf.MakeHazard()
>>> hf[39]
0.49689
\end{verbatim}

So of all pregnancies that proceed until week 39, about
50\% end in week 39.

Figure~\ref{survival1} (bottom) shows the hazard function for
pregnancy lengths.  For times after week 42, the hazard function
is erratic because it is based on a small number of cases.
Other than that the shape of the curve is as expected: it is
highest around 39 weeks, and a little higher in the first
trimester than in the second.
\index{pregnancy length}

The hazard function is useful in its own right, but it is also an
important tool for estimating survival curves, as we'll see in the
next section.


\section{Estimating survival curves}

If someone gives you the CDF of lifetimes, it is easy to compute the
survival and hazard functions.  But in many real-world
scenarios, we can't measure the distribution of lifetimes directly.
We have to infer it.
\index{survival curve}
\index{CDF}

For example, suppose you are following a group of patients to see how
long they survive after diagnosis.  Not all patients are diagnosed on
the same day, so at any point in time, some patients have survived
longer than others.  If some patients have died, we know their
survival times.  For patients who are still alive, we don't know
survival times, but we have a lower bound.
\index{diagnosis}

If we wait until all patients are dead, we can compute the survival
curve, but if we are evaluating the effectiveness of a new treatment,
we can't wait that long!  We need a way to estimate survival curves
using incomplete information.
\index{incomplete information}

As a more cheerful example, I will use NSFG data to quantify how
long respondents ``survive'' until they get married for the
first time.  The range of respondents' ages is 14 to 44 years, so
the dataset provides a snapshot of women at different stages in their
lives.
\index{marital status}

For women who have been married, the dataset includes the date
of their first marriage and their age at the time.
For women who have not been married, we know their age when interviewed,
but have no way of knowing when or if they will get married.
\index{age}

Since we know the age at first marriage for {\em some} women, it
might be tempting to exclude the rest and compute the CDF of
the known data.  That is a bad idea.  The result would
be doubly misleading: (1) older women would be overrepresented,
because they are more likely to be married when interviewed,
and (2) married women would be overrepresented!  In fact, this
analysis would lead to the conclusion that all women get married,
which is obviously incorrect.


\section{Kaplan-Meier estimation}

In this example it is not only desirable but necessary to include
observations of unmarried women, which brings us to one of the central
algorithms in survival analysis, {\bf Kaplan-Meier estimation}.
\index{Kaplan-Meier estimation}

The general idea is that we can use the data to estimate the hazard
function, then convert the hazard function to a survival function.
To estimate the hazard function, we consider, for each age,
(1) the number of women who got married at that age and (2) the number
of women ``at risk'' of getting married, which includes all women
who were not married at an earlier age.
\index{hazard function}
\index{at risk}

Here's the code:

\begin{verbatim}
def EstimateHazardFunction(complete, ongoing, label=''):

    n = len(complete)
    hist_complete = thinkstats2.Hist(complete)
    sf_complete = SurvivalFunction(thinkstats2.Cdf(complete))

    m = len(ongoing)
    sf_ongoing = SurvivalFunction(thinkstats2.Cdf(ongoing))

    lams = {}
    for t, ended in sorted(hist_complete.Items()):
        at_risk = ended + n * sf_complete[t] + m * sf_ongoing[t]
        lams[t] = ended / at_risk

    return HazardFunction(lams, label=label)
\end{verbatim}

{\tt complete} is the set of complete observations; in this case,
the ages when respondents got married.  {\tt ongoing} is the set
of incomplete observations; that is, the ages of unmarried women
when they were interviewed.

First, we precompute \verb"hist_complete", which is the Hist
of ages when women were married, \verb"sf_complete", the
survival function for married women, and \verb"sf_ongoing",
the survival function for unmarried women.
\index{Hist}
\index{survival function}

The loop iterates through the ages when respondents got married.
For each value of {\tt t}, we have {\tt ended}, which is the number
of women who got married at age {\tt t}.  Then we compute
the number of women ``at risk'', which is the sum of:

\begin{itemize}

\item {\tt ended}, the number of respondents married at age {\tt t},

\item \verb"n * sf_complete[t]", the number of respondents
married after age {\tt t}.

\item \verb"m * sf_ongoing[t]", the number of unmarried respondents
interviewed after {\tt t}, and therefore known not to
have been married at or before {\tt t}.

\end{itemize}

The estimated value of the hazard function at {\tt t} is the ratio of
{\tt ended} to \verb"at_risk".

{\tt lams} is a dictionary that maps
from $t$ to $\lambda(t)$.  The result is a {\tt HazardFunction}
object.
\index{HazardFunction}


\section{The marriage curve}

To test this function, we have to do some data cleaning and
transformation.  The NSFG variables we need are:
\index{marital status}

\begin{itemize}

\item {\tt cmbirth}: The respondent's date of birth, known for
all respondents.
\index{date of birth}

\item {\tt cmintvw}: The date the respondent was interviewed,
known for all respondents.

\item {\tt cmmarrhx}: The date the respondent was first married,
if applicable and known.

\item {\tt evrmarry}: 1 if the respondent had been
married prior to the date of interview, 0 otherwise.

\end{itemize}

The first three variables are encoded in ``century-months''; that is, the
integer number of months since December 1899.  So century-month
1 is January 1900.
\index{century month}

First, we read the respondent file and replace invalid values of
{\tt cmmarrhx}:

\begin{verbatim}
    resp = chap01soln.ReadFemResp()
    resp.cmmarrhx.replace([9997, 9998, 9999], np.nan, inplace=True)
\end{verbatim}

Then we compute each respondent's age when married and age when
interviewed:
\index{NaN}

\begin{verbatim}
    resp['agemarry'] = (resp.cmmarrhx - resp.cmbirth) / 12.0
    resp['age'] = (resp.cmintvw - resp.cmbirth) / 12.0
\end{verbatim}

Next
we extract {\tt complete}, which is the age at marriage for
women who have been married, and {\tt ongoing}, which is the
age at interview for women who have not:
\index{age}

\begin{verbatim}
    complete = resp[resp.evrmarry==1].agemarry
    ongoing = resp[resp.evrmarry==0].age
\end{verbatim}

Finally we compute the
hazard function.
\index{hazard function}

\begin{verbatim}
    hf = EstimateHazardFunction(complete, ongoing)
\end{verbatim}

Figure~\ref{survival2} (top) shows the estimated hazard function;
it is low in the teens,
higher in the 20s, and declining in the 30s.  It increases again in
the 40s, but that is an artifact of the estimation process; as the
number of respondents ``at risk'' decreases, a small number of
women getting married yields a large estimated hazard.  The survival
function will smooth out this noise.
\index{noise}


\section{Estimating the survival function}

Once we have the hazard function, we can estimate the survival function.
The chance of surviving past time {\tt t} is the chance of surviving
all times up through {\tt t}, which is the cumulative product of
the complementary hazard function:
%
\[ [1-\lambda(0)] [1-\lambda(1)] ... [1-\lambda(t)] \]
%
The {\tt HazardFunction} class provides {\tt MakeSurvival}, which
computes this product:
\index{cumulative product}
\index{SurvivalFunction}

\begin{verbatim}
# class HazardFunction:

    def MakeSurvival(self):
        ts = self.series.index
        ss = (1 - self.series).cumprod()
        cdf = thinkstats2.Cdf(ts, 1-ss)
        sf = SurvivalFunction(cdf)
        return sf
\end{verbatim}

{\tt ts} is the sequence of times where the hazard function is
estimated.  {\tt ss} is the cumulative product of the complementary
hazard function, so it is the survival function.

Because of the way {\tt SurvivalFunction} is implemented, we have
to compute the complement of {\tt ss}, make a Cdf, and then instantiate
a SurvivalFunction object.
\index{Cdf}
\index{complementary CDF}


\begin{figure}
% survival.py
\centerline{\includegraphics[height=2.5in]{figs/survival2.pdf}}
\caption{Hazard function for age at first marriage (top) and
survival function (bottom).}
\label{survival2}
\end{figure}

Figure~\ref{survival2} (bottom) shows the result.  The survival
curve is steepest between 25 and 35, when most women get married.
Between 35 and 45,
the curve is nearly flat, indicating that women who do not marry
before age 35 are unlikely to get married.

A curve like this was the basis of a famous magazine article in 1986;
{\it Newsweek} reported that a 40-year old unmarried woman was ``more
likely to be killed by a terrorist'' than get married.  These
statistics were widely reported and became part of popular culture,
but they were wrong then (because they were based on faulty analysis)
and turned out to be even more wrong (because of cultural changes that
were already in progress and continued).  In 2006, {\it Newsweek} ran
an another article admitting that they were wrong.
\index{Newsweek}

I encourage you to read more about this article, the statistics it was
based on, and the reaction.  It should remind you of the ethical
obligation to perform statistical analysis with care, interpret the
results with appropriate skepticism, and present them to the public
accurately and honestly.
\index{ethics}


\section{Confidence intervals}

Kaplan-Meier analysis yields a single estimate of the survival curve,
but it is also important to quantify the uncertainty of the estimate.
As usual, there are three possible sources of error: measurement
error, sampling error, and modeling error.
\index{confidence interval}
\index{modeling error}
\index{sampling error}

In this example, measurement error is probably small.  People
generally know when they were born, whether they've been married, and
when.  And they can be expected to report this information accurately.
\index{measurement error}

We can quantify sampling error by resampling.  Here's the code:
\index{resampling}

\begin{verbatim}
def ResampleSurvival(resp, iters=101):
    low, high = resp.agemarry.min(), resp.agemarry.max()
    ts = np.arange(low, high, 1/12.0)

    ss_seq = []
    for i in range(iters):
        sample = thinkstats2.ResampleRowsWeighted(resp)
        hf, sf = EstimateSurvival(sample)
        ss_seq.append(sf.Probs(ts))

    low, high = thinkstats2.PercentileRows(ss_seq, [5, 95])
    thinkplot.FillBetween(ts, low, high)
\end{verbatim}

{\tt ResampleSurvival} takes {\tt resp}, a DataFrame of respondents,
and {\tt iters}, the number of times to resample.  It computes {\tt
  ts}, which is the sequence of ages where we will evaluate the survival
functions.
\index{DataFrame}

Inside the loop, {\tt ResampleSurvival}:

\begin{itemize}

\item Resamples the respondents using {\tt ResampleRowsWeighted},
which we saw in Section~\ref{weighted}.
\index{weighted resampling}

\item Calls {\tt EstimateSurvival}, which uses the process in the
previous sections to estimate the hazard and survival curves, and

\item Evaluates the survival curve at each age in {\tt ts}.

\end{itemize}

\verb"ss_seq" is a sequence of evaluated survival curves.
{\tt PercentileRows} takes this sequence and computes the 5th and 95th
percentiles, returning a 90\% confidence interval for the survival
curve.
\index{FillBetween}

\begin{figure}
% survival.py
\centerline{\includegraphics[height=2.5in]{figs/survival3.pdf}}
\caption{Survival function for age at first marriage and a 90\%
confidence interval based on weighted resampling.}
\label{survival3}
\end{figure}

Figure~\ref{survival3} shows the result along with the survival
function we estimated in the previous section.  The confidence
interval takes into account the sampling weights, unlike the estimated
curve.  The discrepancy between them indicates that the sampling
weights have a substantial effect on the estimate---we will have
to keep that in mind.
\index{confidence interval}
\index{sampling weight}


\section{Cohort effects}

One of the challenges of survival analysis is that different parts
of the estimated curve are based on different groups of respondents.
The part of the curve at time {\tt t} is based on respondents
whose age was at least {\tt t} when they were interviewed.
So the leftmost part of the curve includes data from all respondents,
but the rightmost part includes only the oldest respondents.

If the relevant characteristics of the respondents are not changing
over time, that's fine, but in this case it seems likely that marriage
patterns are different for women born in different generations.
We can investigate this effect by grouping respondents according
to their decade of birth.  Groups like this, defined by date of
birth or similar events, are called {\bf cohorts}, and differences
between the groups are called {\bf cohort effects}.
\index{cohort}
\index{cohort effect}

To investigate cohort effects in the NSFG marriage data, I gathered
the Cycle 6 data from 2002 used throughout this book;
the Cycle 7 data from 2006--2010 used in Section~\ref{replication};
and the Cycle 5 data from 1995.  In total these datasets include
30,769 respondents.

\begin{verbatim}
    resp5 = ReadFemResp1995()
    resp6 = ReadFemResp2002()
    resp7 = ReadFemResp2010()
    resps = [resp5, resp6, resp7]
\end{verbatim}

For each DataFrame, {\tt resp}, I use {\tt cmbirth} to compute the
decade of birth for each respondent:
\index{pandas}
\index{DataFrame}

\begin{verbatim}
    month0 = pandas.to_datetime('1899-12-15')
    dates = [month0 + pandas.DateOffset(months=cm) 
             for cm in resp.cmbirth]
    resp['decade'] = (pandas.DatetimeIndex(dates).year - 1900) // 10
\end{verbatim}

{\tt cmbirth} is encoded as the integer number of months since
December 1899; {\tt month0} represents that date as a Timestamp
object.  For each birth date, we instantiate a {\tt DateOffset} that
contains the century-month and add it to {\tt month0}; the result
is a sequence of Timestamps, which is converted to a {\tt
  DateTimeIndex}.  Finally, we extract {\tt year} and compute
decades.
\index{DateTimeIndex}
\index{Index}
\index{century month}

To take into account the sampling weights, and also to show
variability due to sampling error, I resample the data,
group respondents by decade, and plot survival curves:
\index{resampling}
\index{sampling error}

\begin{verbatim}
    for i in range(iters):
        samples = [thinkstats2.ResampleRowsWeighted(resp) 
                   for resp in resps]
        sample = pandas.concat(samples, ignore_index=True)
        groups = sample.groupby('decade')

        EstimateSurvivalByDecade(groups, alpha=0.2)
\end{verbatim}

Data from the three NSFG cycles use different sampling weights,
so I resample them separately and then use {\tt concat}
to merge them into a single DataFrame.  The parameter \verb"ignore_index"
tells {\tt concat} not to match up respondents by index; instead
it creates a new index from 0 to 30768.
\index{pandas}
\index{DataFrame}
\index{groupby}

{\tt EstimateSurvivalByDecade} plots survival curves for each cohort:

\begin{verbatim}
def EstimateSurvivalByDecade(resp):
    for name, group in groups:
        hf, sf = EstimateSurvival(group)
        thinkplot.Plot(sf)
\end{verbatim}

\begin{figure}
% survival.py
\centerline{\includegraphics[height=2.5in]{figs/survival4.pdf}}
\caption{Survival functions for respondents born during different decades.}
\label{survival4}
\end{figure}

Figure~\ref{survival4} shows the results.  Several patterns are
visible:

\begin{itemize}

\item Women born in the 50s married earliest, with successive
  cohorts marrying later and later, at least until age 30 or so.

\item Women born in the 60s follow a surprising pattern.  Prior
to age 25, they were marrying at slower rates than their predecessors.
After age 25, they were marrying faster.  By age 32 they had overtaken
the 50s cohort, and at age 44 they are substantially more likely to
have married.
\index{marital status}

Women born in the 60s turned 25 between 1985 and 1995.  Remembering
that the {\it Newsweek} article I mentioned was published in 1986, it
is tempting to imagine that the article triggered a marriage boom.
That explanation would be too pat, but it is possible that the article
and the reaction to it were indicative of a mood that affected the
behavior of this cohort.
\index{Newsweek}

\item The pattern of the 70s cohort is similar.  They are less
likely than their predecessors to be married before age 25, but
at age 35 they have caught up with both of the previous cohorts.

\item Women born in the 80s are even less likely to marry before
age 25.  What happens after that is not clear; for more data, we
have to wait for the next cycle of the NSFG.

\end{itemize}

In the meantime we can make some predictions.
\index{prediction}


\section{Extrapolation}

The survival curve for the 70s cohort ends at about age 38;
for the 80s cohort it ends at age 28, and for the 90s cohort
we hardly have any data at all.
\index{extrapolation}

We can extrapolate these curves by ``borrowing'' data from the
previous cohort.  HazardFunction provides a method, {\tt Extend}, that
copies the tail from another longer HazardFunction:
\index{HazardFunction}

\begin{verbatim}
# class HazardFunction

    def Extend(self, other):
        last = self.series.index[-1]
        more = other.series[other.series.index > last]
        self.series = pandas.concat([self.series, more])
\end{verbatim}

As we saw in Section~\ref{hazard}, the HazardFunction contains a Series
that maps from $t$ to $\lambda(t)$.  {\tt Extend} finds {\tt last},
which is the last index in {\tt self.series}, selects values from
{\tt other} that come later than {\tt last}, and appends them
onto {\tt self.series}.
\index{pandas}
\index{Series}

Now we can extend the HazardFunction for each cohort, using values
from the predecessor:

\begin{verbatim}
def PlotPredictionsByDecade(groups):
    hfs = []
    for name, group in groups:
        hf, sf = EstimateSurvival(group)
        hfs.append(hf)

    thinkplot.PrePlot(len(hfs))
    for i, hf in enumerate(hfs):
        if i > 0:
            hf.Extend(hfs[i-1])
        sf = hf.MakeSurvival()
        thinkplot.Plot(sf)
\end{verbatim}

{\tt groups} is a GroupBy object with respondents grouped by decade of
birth.  The first loop computes the HazardFunction for each group.
\index{groupby}

The second loop extends each HazardFunction with values from
its predecessor, which might contain values from the previous
group, and so on.  Then it converts each HazardFunction to
a SurvivalFunction and plots it.

\begin{figure}
% survival.py
\centerline{\includegraphics[height=2.5in]{figs/survival5.pdf}}
\caption{Survival functions for respondents born during different decades,
with predictions for the later cohorts.}
\label{survival5}
\end{figure}

Figure~\ref{survival5} shows the results; I've removed the 50s cohort
to make the predictions more visible.  These results suggest that by
age 40, the most recent cohorts will converge with the 60s cohort,
with fewer than 20\% never married.
\index{visualization}


\section{Expected remaining lifetime}

Given a survival curve, we can compute the expected remaining
lifetime as a function of current age.  For example, given the
survival function of pregnancy length from Section~\ref{survival},
we can compute the expected time until delivery.
\index{pregnancy length}

The first step is to extract the PMF of lifetimes.  {\tt SurvivalFunction}
provides a method that does that:

\begin{verbatim}
# class SurvivalFunction

    def MakePmf(self, filler=None):
        pmf = thinkstats2.Pmf()
        for val, prob in self.cdf.Items():
            pmf.Set(val, prob)

        cutoff = self.cdf.ps[-1]
        if filler is not None:
            pmf[filler] = 1-cutoff

        return pmf
\end{verbatim}

Remember that the SurvivalFunction contains the Cdf of lifetimes.
The loop copies the values and probabilities from the Cdf into
a Pmf.
\index{Pmf}
\index{Cdf}

{\tt cutoff} is the highest probability in the Cdf, which is 1
if the Cdf is complete, and otherwise less than 1.  
If the Cdf is incomplete, we plug in the provided value, {\tt filler},
to cap it off.

The Cdf of pregnancy lengths is complete, so we don't have to worry
about this detail yet.
\index{pregnancy length}

The next step is to compute the expected remaining lifetime, where
``expected'' means average.  {\tt SurvivalFunction}
provides a method that does that, too:
\index{expected remaining lifetime}

\begin{verbatim}
# class SurvivalFunction

    def RemainingLifetime(self, filler=None, func=thinkstats2.Pmf.Mean):
        pmf = self.MakePmf(filler=filler)
        d = {}
        for t in sorted(pmf.Values())[:-1]:
            pmf[t] = 0
            pmf.Normalize()
            d[t] = func(pmf) - t

        return pandas.Series(d)
\end{verbatim}

{\tt RemainingLifetime} takes {\tt filler}, which is passed along
to {\tt MakePmf}, and {\tt func} which is the function used to
summarize the distribution of remaining lifetimes.

{\tt pmf} is the Pmf of lifetimes extracted from the SurvivalFunction.
{\tt d} is a dictionary that contains the results, a map from
current age, {\tt t}, to expected remaining lifetime.
\index{Pmf}

The loop iterates through the values in the Pmf.  For each value
of {\tt t} it computes the conditional distribution of lifetimes,
given that the lifetime exceeds {\tt t}.  It does that by removing
values from the Pmf one at a time and renormalizing the remaining
values.

Then it uses {\tt func} to summarize the conditional distribution.
In this example the result is the mean pregnancy length, given that
the length exceeds {\tt t}.  By subtracting {\tt t} we get the
mean remaining pregnancy length.
\index{pregnancy length}

\begin{figure}
% survival.py
\centerline{\includegraphics[height=2.5in]{figs/survival6.pdf}}
\caption{Expected remaining lifetime for pregnancy length (left) and
years until first marriage (right).}
\label{survival6}
\end{figure}

Figure~\ref{survival6} (left) shows the expected remaining pregnancy
length as a function of the current duration.  For example, during
Week 0, the expected remaining duration is about 34 weeks.  That's
less than full term (39 weeks) because terminations of pregnancy
in the first trimester bring the average down.
\index{pregnancy length}

The curve drops slowly during the first trimester.  After 13 weeks,
the expected remaining lifetime has dropped by only 9 weeks, to
25.  After that the curve drops faster, by about a week per week.

Between Week 37 and 42, the curve levels off between 1 and 2 weeks.
At any time during this period, the expected remaining lifetime is the
same; with each week that passes, the destination gets no closer.
Processes with this property are called {\bf memoryless} because
the past has no effect on the predictions.
This behavior is the mathematical basis of the infuriating mantra
of obstetrics nurses: ``any day now.''
\index{memoryless}

Figure~\ref{survival6} (right) shows the median remaining time until
first marriage, as a function of age.  For an 11 year-old girl, the
median time until first marriage is about 14 years.  The curve decreases
until age 22 when the median remaining time is about 7 years.
After that it increases again: by age 30 it is back where it started,
at 14 years.

Based on this data, young women have decreasing remaining
"lifetimes".  Mechanical components with this property are called {\bf NBUE}
for "new better than used in expectation," meaning that a new part is
expected to last longer.
\index{NBUE}

Women older than 22 have increasing remaining time until first
marriage.  Components with this property are called {\bf UBNE} for
"used better than new in expectation."  That is, the older the part,
the longer it is expected to last.  Newborns and cancer patients are
also UBNE; their life expectancy increases the longer they live.
\index{UBNE}

For this example I computed median, rather than mean, because the
Cdf is incomplete; the survival curve projects that about 20\%
of respondents will not marry before age 44.  The age of
first marriage for these women is unknown, and might be non-existent,
so we can't compute a mean.
\index{Cdf}
\index{median}

I deal with these unknown values by replacing them with {\tt np.inf},
a special value that represents infinity.  That makes the mean
infinity for all ages, but the median is well-defined as long as
more than 50\% of the remaining lifetimes are finite, which is true
until age 30.  After that it is hard to define a meaningful
expected remaining lifetime.
\index{inf}

Here's the code that computes and plots these functions:

\begin{verbatim}
    rem_life1 = sf1.RemainingLifetime()
    thinkplot.Plot(rem_life1)

    func = lambda pmf: pmf.Percentile(50)
    rem_life2 = sf2.RemainingLifetime(filler=np.inf, func=func)
    thinkplot.Plot(rem_life2)
\end{verbatim}

{\tt sf1} is the survival function for pregnancy length;
in this case we can use the default values for {\tt RemainingLifetime}.
\index{pregnancy length}

{\tt sf2} is the survival function for age at first marriage;
{\tt func} is a function that takes a Pmf and computes its
median (50th percentile).
\index{Pmf}


\section{Exercises}

My solution to this exercise is in \verb"chap13soln.py".

\begin{exercise}
In NSFG Cycles 6 and 7, the variable {\tt cmdivorcx} contains the
date of divorce for the respondent's first marriage, if applicable,
encoded in century-months.
\index{divorce}
\index{marital status}

Compute the duration of marriages that have ended in divorce, and
the duration, so far, of marriages that are ongoing.  Estimate the
hazard and survival function for the duration of marriage.

Use resampling to take into account sampling weights, and plot
data from several resamples to visualize sampling error.
\index{resampling}

Consider dividing the respondents into groups by decade of birth,
and possibly by age at first marriage.
\index{groupby}

\end{exercise}


\section{Glossary}

\begin{itemize}

\item survival analysis: A set of methods for describing and
  predicting lifetimes, or more generally time until an event occurs.
\index{survival analysis}

\item survival curve: A function that maps from a time, $t$, to the
  probability of surviving past $t$.
\index{survival curve}

\item hazard function: A function that maps from $t$ to the fraction
of people alive until $t$ who die at $t$.
\index{hazard function}

\item Kaplan-Meier estimation: An algorithm for estimating hazard and
survival functions.
\index{Kaplan-Meier estimation}

\item cohort: a group of subjects defined by an event, like date of
birth, in a particular interval of time.
\index{cohort}

\item cohort effect: a difference between cohorts.
\index{cohort effect}

\item NBUE: A property of expected remaining lifetime, ``New
better than used in expectation.''
\index{NBUE}

\item UBNE: A property of expected remaining lifetime, ``Used
better than new in expectation.''
\index{UBNE}

\end{itemize}

